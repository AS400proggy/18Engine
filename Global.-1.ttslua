--Any line proceeded by -- is a lua comment, and can safely be deleted.

--This script is powered by 18Engine, an easy-to-use, all-purpose script for 18xx games.
--https://github.com/goldencow2/18Engine/wiki

USE_SAVES = false
--set this to false while editing your mod or treasuries will persist.
--set this to true, copy in the script, use "save and play" from the modding menu, and then actually save your mod to enable saves (TTS is dumb).
--WARNING: If you intend on modifying any gameOptions, turn use_saves to false first.
---------- As of this writing this should only be an issue for BANK_SIZE.

gameOptions = {

}

gameEntities = {
    OTHER_ACTORS = {
            ['BANK'] = {
                moneyLabelGUID = '',
            },
            ['PRIVATES'] = {
                payPrivatesButtonGUID = ''
            },

    }, COMPANIES = {
            ['Example Company'] = {
                inputCounterGUID = '',
                moneyLabelGUID = '',
                charterGUID = '',
            },

            ['Example Company2'] = {
                inputCounterGUID = '',
                moneyLabelGUID = '',
                charterGUID = '',
            },

            --- etc.

    }, PLAYERS = {
            ['Red'] = {
                inputCounterGUID = '',
                moneyLabelGUID = '',
            },

            ['White'] = {
                inputCounterGUID = '',
                moneyLabelGUID = '',
            },

            --- etc.

    }
}

---VERSION 2.0, copy and paste everything below this line to update!

-----You probably shouldn't edit these unless you know what you're doing.
    -----They can be overwritten by including the option in gameOptions.
gameOptionDefaults = {
    COMPANIES_CAN_FULL_PAY = true,
    COMPANIES_CAN_HALF_PAY = false,
    HALF_PAY_ROUND = 10, --Round the payout of a half-pay to the nearest multiple of this, in favor of the players.
    BANK_SIZE = nil,
    TRANSACTION_LOG_GUID = nil,
    MONEY_SYMBOL = nil,
    MONEY_SYMBOL_POSITION = nil,
    BANK_POOL_SHARES_PAY_COMPANY = false,
    BANK_POOL_ZONE_GUID = nil,
    IPO_SHARES_PAY_COMPANY = false,
    IPO_ZONE_GUID = nil,
    CHARTER_SHARES_PAY_COMPANY = false,
    COMPANIES_CAN_CROSS_INVEST = false, --Companies can own shares in other companies (the script will pay foreign shares on charters)
    SHARE_DESCRIPTIONS_ARE_PERCENTAGE = false, --The number appended to a share's description is the % of the revenue it will receive e.g 'B&O20' = 20%, 'UdW5' = 5%
    USE_PRIVATES = false, --If set to true, script excpects you to supply a GUID for an object to stick a "pay privates" button on.
    COMPANIES_CAN_OWN_PRIVATES = true, --if set to false, the script won't ask you to supply charter GUIDs (Note: not implemented yet)

    COMPANY_CHARTERS_ARE_SHARES = false, --The charter itself represents 1 share.
    --This will also set the company to assume only 1 share exists, and the player who presses the payout button will be paid for it.
    --This also sets the HALF_PAY_ROUND for the company to 1.

    PROPORTIONAL_PAYOUTS = false,
    -- The payout per share will be the total dividend divided by the number of shares paid.
    -- e.g, if only 7 shares are owned by players/companies then the dividend is split 7 ways.
    -- The per share dividend is rounded down before multiplying, with any remainder going to the company unless one player/company owns 100% of the shares.
}

-----YOU DO NOT NEED TO EDIT ANYTHING BELOW THIS LINE-----
SAVE_STATE = {
    versionNumber = 2.0
}

function onSave()
    --saved_data = JSON.encode(gameEntities)
    if not USE_SAVES then
        saved_data = ''
    else
        --bank amount
        SAVE_STATE['Bank Treasury'] = gameEntities.OTHER_ACTORS['BANK'].treasury

        --company treasuries
        for k,company in pairs(gameEntities.COMPANIES) do
            SAVE_STATE['Company ' .. k] = company.treasury
        end

        --player treasuries
        for k,player in pairs(gameEntities.PLAYERS) do
            SAVE_STATE['Player ' .. k] = player.treasury
        end

        saved_data = JSON.encode(SAVE_STATE)
    end
    return saved_data
end

function onload(saved_data)
    if saved_data~='' then
        SAVE_STATE = JSON.decode(saved_data)
    end
    initCompanies()
    initPlayers()
    initBank()
    initPrivates()
    initLog()
    initIPO()
    initBankPool()
end

function initCompanies()
    for k,company in pairs(gameEntities.COMPANIES) do
        --error checking
        if not company.moneyLabelGUID then
            broadcastToAll('ERROR: No "moneyLabelGUID" entry was found for the ' .. k .. ' Company', ERROR_COLOR) return
        end
        if not getObjectFromGUID(company.moneyLabelGUID) then
            broadcastToAll('ERROR: An object could not be found for the ' .. k .. ' Company\'s moneyLabelGUID.', ERROR_COLOR) return
        end
        if not company.inputCounterGUID then
            broadcastToAll('ERROR: No "inputCounterGUID" entry was found for the ' .. k .. ' Company', ERROR_COLOR) return
        end
        if not getObjectFromGUID(company.inputCounterGUID) then
            broadcastToAll('ERROR: An object could not be found for the ' .. k .. ' Company\'s inputCounterGUID.', ERROR_COLOR) return
        end
        if not company.charterGUID then
            broadcastToAll('ERROR: No "charterGUID" entry was found for the ' .. k .. ' Company', ERROR_COLOR) return
        end
        if not getObjectFromGUID(company.charterGUID) then
            broadcastToAll('ERROR: An object could not be found for the ' .. k .. ' Company\'s charterGUID.', ERROR_COLOR) return
        end

        --Copy over or override global options
        for j,v in pairs(gameOptionDefaults) do
            if company[j]==nil then
                if gameOptions[j]==nil then
                    company[j] = v
                else
                    company[j] = gameOptions[j]
                end
            end
        end

        company.key = k
        if not company.name then company.name = k end
        if not company.shareDescription then company.shareDescription = k end
        if not company.issueSize then company.issueSize = 10 end
        if SAVE_STATE['Company ' .. k] then
            company.treasury = SAVE_STATE['Company ' .. k]
        else
            company.treasury = 0
        end

        if company.COMPANY_CHARTERS_ARE_SHARES then
            company.issueSize = 2
            company.SHARE_DESCRIPTIONS_ARE_PERCENTAGE = false
            company.HALF_PAY_ROUND = 1
            getObjectFromGUID(company.inputCounterGUID).setName('This Company will pay the player who clicks the button.')
        end

        updateLabel(company)

        --fucking LUA wizardry
        --Using a locally defined function as the click_function allows us to access the other local variables in this for loop
        local bTParam = bankTransferParams
        local wParam = withholdParams
        local pFParam = payFullParams
        local pHParam = payHalfParams

        if company.COMPANIES_CAN_HALF_PAY then
            local payFuncName = k .. 'PayHalf'
            local payFunc = function(object, color) buttonHelper(company, 'PayHalf', color) end
            Global.setVar(payFuncName, payFunc)
            pHParam.click_function = payFuncName
            getObjectFromGUID(company.inputCounterGUID).createButton(pHParam)
        end

        if company.COMPANIES_CAN_FULL_PAY then
            local payFuncName = k .. 'Payout'
            local payFunc = function(object, color) buttonHelper(company, 'Payout', color) end
            Global.setVar(payFuncName, payFunc)
            pFParam.click_function = payFuncName
            getObjectFromGUID(company.inputCounterGUID).createButton(pFParam)
        end

        if company.COMPANIES_CAN_HALF_PAY and company.COMPANIES_CAN_FULL_PAY then
            getObjectFromGUID(company.inputCounterGUID).editButton({index=0, position = addv(pHParam.position,{0,0,-0.2})})
            getObjectFromGUID(company.inputCounterGUID).editButton({index=1, label='Pay Full', position = addv(pFParam.position,{0,0,0.2})})
        end

        local bankFuncName = k .. 'bankTransfer'
        local bankFunc = function(object, color) buttonHelper(company, 'Bank Transfer') end
        Global.setVar(bankFuncName, bankFunc)
        bTParam.click_function = bankFuncName
        getObjectFromGUID(company.inputCounterGUID).createButton(bTParam)

        local withholdFuncName = k .. 'withholdTransfer'
        local withholdFunc = function(object, color) buttonHelper(company, 'Withhold') end
        Global.setVar(withholdFuncName, withholdFunc)
        wParam.click_function = withholdFuncName
        getObjectFromGUID(company.inputCounterGUID).createButton(wParam)
    end
end

function initPlayers()
    for k,player in pairs(gameEntities.PLAYERS) do
        --error checking
        if not player.moneyLabelGUID then
            broadcastToAll('ERROR: No "moneyLabelGUID" entry was found for the ' .. k .. ' Player', ERROR_COLOR) return
        end
        if not getObjectFromGUID(player.moneyLabelGUID) then
            broadcastToAll('ERROR: An object could not be found for the ' .. k .. ' Player\'s moneyLabelGUID.', ERROR_COLOR) return
        end
        if not player.inputCounterGUID then
            broadcastToAll('ERROR: No "inputCounterGUID" entry was found for the ' .. k .. ' Player', ERROR_COLOR) return
        end
        if not getObjectFromGUID(player.inputCounterGUID) then
            broadcastToAll('ERROR: An object could not be found for the ' .. k .. ' Player\'s inputCounterGUID.', ERROR_COLOR) return
        end
        if player.shareZoneGUID then
            if not getObjectFromGUID(player.shareZoneGUID) then
                broadcastToAll('ERROR: shareZoneGUID is set and an object could not be found for the ' .. k .. ' Player\'s shareZoneGUID.', ERROR_COLOR) return
            end
        end

        local isValidColor = false;
        for _,c in ipairs(Player.getAvailableColors()) do
            if (k == c) then isValidColor = true end
        end
        if not isValidColor then broadcastToAll('ERROR: Player color ' .. k .. ' is set in gameEntities but no hand zone for ' .. k .. ' was found.', ERROR_COLOR) end

        --okay
        player.key = k
        if Player[k].seated then player.name = Player[k].steam_name else player.name = k end
        if SAVE_STATE['Player ' .. k] then
            player.treasury = SAVE_STATE['Player ' .. k]
        else
            player.treasury = 0
        end
        updateLabel(player)

        --Using a locally defined function as the click_function allows us to access the other local variables in this for loop
        local bankFuncName = k .. 'bankTransfer'
        local bankFunc = function(object, color) buttonHelper(player, 'Bank Transfer') end
        Global.setVar(bankFuncName, bankFunc)
        bankTransferParams.click_function = bankFuncName
        getObjectFromGUID(player.inputCounterGUID).createButton(bankTransferParams)

        local withholdFuncName = k .. 'withholdTransfer'
        local withholdFunc = function(object, color) buttonHelper(player, 'Withhold') end
        Global.setVar(withholdFuncName, withholdFunc)
        withholdParams.click_function = withholdFuncName
        getObjectFromGUID(player.inputCounterGUID).createButton(withholdParams)
    end
end

function initIPO()
    --if global or any company has IPO_SHARES_PAY_COMPANY, enforce a GUID and fetch bank pool zone
    local usingIPO = gameOptions.IPO_SHARES_PAY_COMPANY
    for k,v in pairs(gameEntities.COMPANIES) do
        usingIPO = usingIPO or v.IPO_SHARES_PAY_COMPANY
    end

    --if using IPO, check to see if the GUID is set.
    if usingIPO then
        if not (gameOptions.IPO_ZONE_GUID) then
            broadcastToAll('IPO_SHARES_PAY_COMPANY is set for at least one company but could not find IPO_ZONE_GUID in gameOptions', ERROR_COLOR) return
        end
        if not getObjectFromGUID(gameOptions.IPO_ZONE_GUID) then
            broadcastToAll('ERROR: IPO_ZONE_GUID does not match anything in this mod.', ERROR_COLOR) return
        end

        --error free
        IPO_ZONE = getObjectFromGUID(gameOptions.IPO_ZONE_GUID)
    end
end

function initBankPool()
    --if global or any company has BANK_SHARES_PAY_COMPANY, enforce a GUID and fetch bank pool zone
    local usingBankPool = gameOptions.BANK_POOL_SHARES_PAY_COMPANY
    for k,v in pairs(gameEntities.COMPANIES) do
        usingBankPool = usingBankPool or v.BANK_POOL_SHARES_PAY_COMPANY
    end

    --if using bank pool, check to see if the GUID is set.
    if usingBankPool then
        if not (gameOptions.BANK_POOL_ZONE_GUID) then
            broadcastToAll('BANK_POOL_SHARES_PAY_COMPANY is set for at least one company but could not find BANK_POOL_ZONE_GUID in gameOptions', ERROR_COLOR) return
        end
        if not getObjectFromGUID(gameOptions.BANK_POOL_ZONE_GUID) then
            broadcastToAll('ERROR: BANK_POOL_ZONE_GUID does not match anything in this mod.', ERROR_COLOR) return
        end

        --error free
        BANK_POOL_ZONE = getObjectFromGUID(gameOptions.BANK_POOL_ZONE_GUID)
    end
end

function initBank()
    --Check if there should be a bank.
    USE_BANK = gameOptions.BANK_SIZE
    if USE_BANK and not gameEntities.OTHER_ACTORS['BANK'] then broadcastToAll('ERROR: Bank size is non-zero but no "BANK" entry was found in gameEntities.OTHER_ACTORS', ERROR_COLOR) return end

    if USE_BANK then
        --error checking
        if not gameEntities.OTHER_ACTORS['BANK'].moneyLabelGUID then
            broadcastToAll('ERROR: No "moneyLabelGUID" entry was found in gameEntities.OTHER_ACTORS[\'BANK\'].', ERROR_COLOR) return
        end
        if not getObjectFromGUID(gameEntities.OTHER_ACTORS['BANK'].moneyLabelGUID) then
            broadcastToAll('ERROR: An object could not be found for the bank\'s moneyLabelGUID.', ERROR_COLOR) return
        end

        --Okay
        if SAVE_STATE['Bank Treasury'] then
            gameEntities.OTHER_ACTORS['BANK'].treasury = SAVE_STATE['Bank Treasury']
        else
            gameEntities.OTHER_ACTORS['BANK'].treasury = gameOptions.BANK_SIZE
        end

        updateLabel(gameEntities.OTHER_ACTORS['BANK'])
    end
end

function initPrivates()
    if gameOptions.USE_PRIVATES and not gameEntities.OTHER_ACTORS['PRIVATES'] then broadcastToAll('ERROR: USE_PRIVATES is set but no "PRIVATES" entry was found in gameEntities.OTHER_ACTORS', ERROR_COLOR) return end

    if gameOptions.USE_PRIVATES then
        --error checking
        if not gameEntities.OTHER_ACTORS['PRIVATES'].payPrivatesButtonGUID then
            broadcastToAll('ERROR: No "payPrivatesButtonGUID" entry was found in gameEntities.OTHER_ACTORS[\'PRIVATES\'].', ERROR_COLOR) return
        end
        if not getObjectFromGUID(gameEntities.OTHER_ACTORS['PRIVATES'].payPrivatesButtonGUID) then
            broadcastToAll('ERROR: An object could not be found for the privatess\' payPrivatesButtonGUID.', ERROR_COLOR) return
        end

        --Okay
        getObjectFromGUID(gameEntities.OTHER_ACTORS['PRIVATES'].payPrivatesButtonGUID).createButton(payPrivatesParams)
    end
end

function initLog()
    if gameOptions.TRANSACTION_LOG_GUID then
        --error checking
        if not getObjectFromGUID(gameOptions.TRANSACTION_LOG_GUID) then
            broadcastToAll('ERROR: TRANSACTION_LOG_GUID was set but an object with that GUID could not be found.', ERROR_COLOR) return
        end

        --Okay
        TRANSACTION_LOG = getObjectFromGUID(gameOptions.TRANSACTION_LOG_GUID)
        TRANSACTION_LOG.setName('Transaction Log')
        TRANSACTION_LOG.setDescription('')

        TRANSACTIONS = nil
    end
end

function buttonHelper(caller, type, color)
    local amount = getObjectFromGUID(caller.inputCounterGUID).getValue()
    if amount == 0 then return end
    if type == 'Bank Transfer' then
        amount = amount*-1
        transferMoneyWithBank(caller, amount, true, true)
    elseif type == 'Payout' then
        Payout(caller, amount, color)
    elseif type == 'Withhold' then
        Withhold(caller, amount)
    elseif type == 'PayHalf' then
        printToAll('')
        Payout(caller, roundTo(amount/2, caller.HALF_PAY_ROUND, true), color)
        Withhold(caller, roundTo(amount/2, caller.HALF_PAY_ROUND, false), color)
    end
end

function transferMoneyWithBank(caller, amount, print, log)
    --print = boolean, print to all chat?
    --log = boolean, print to the log object?
    caller.treasury = caller.treasury + amount
    updateLabel(caller)
    if USE_BANK then
        gameEntities.OTHER_ACTORS['BANK'].treasury = gameEntities.OTHER_ACTORS['BANK'].treasury - amount
        updateLabel(gameEntities.OTHER_ACTORS['BANK'])
    end
    if (amount > 0) then
        logTransaction(amount, 'Bank', caller.name, print, log)
    elseif (amount < 0) then
        logTransaction(amount*-1, caller.name, 'Bank', print, log)
    end
end

function Withhold(caller, amount)
    transferMoneyWithBank(caller, amount, true, true)
end

function Payout(caller, amount, color)
    local payoutTable = {}
    --Part of this function spawns ScriptingZones, which take more than one frame to load.
    --The waitFlags are used to make sure all ScriptingZones have loaded and done their thing before continuing.

    local waitFlags = {}

    if caller.COMPANY_CHARTERS_ARE_SHARES then
        payoutTable[color] = {gameEntities.PLAYERS[color], 2}
    else
        --tabulate player shares
        for k,v in pairs(gameEntities.PLAYERS) do
            payoutTable[k] = {v, 0}
            --if player has a designated zone, search that for shares matching this company
            if getObjectFromGUID(v.shareZoneGUID) then
                payoutTable[k][2] = searchContainer(getObjectFromGUID(v.shareZoneGUID).getObjects(), caller, payoutTable[k][2])
            end
            --search the player's hand
            payoutTable[k][2] = searchContainer(Player[k].getHandObjects(), caller, payoutTable[k][2])
        end

        --tabulate company shares
            payoutTable[caller.key] = {caller, 0}
            --bank pool
            if caller.BANK_POOL_SHARES_PAY_COMPANY then
                payoutTable[caller.key][2] = searchContainer(BANK_POOL_ZONE.getObjects(), caller, payoutTable[caller.key][2])
            end
            --IPO
            if caller.IPO_SHARES_PAY_COMPANY then
                payoutTable[caller.key][2] = searchContainer(IPO_ZONE.getObjects(), caller, payoutTable[caller.key][2])
            end
            --Charter
            if caller.CHARTER_SHARES_PAY_COMPANY then
                waitFlags[caller.key] = false

                --Dynamically spawn a scripting zone to on the charter
                local bb = getObjectFromGUID(caller.charterGUID).getBoundsNormalized()
                local params = {}
                local callbackName = "callback" .. caller.key
                params.position = getObjectFromGUID(caller.charterGUID).getPosition()
                params.rotation = getObjectFromGUID(caller.charterGUID).getRotation()
                params.scale = { bb.size.x, bb.size.y+2, bb.size.z }
                params.callback = callbackName
                params.type = 'ScriptingTrigger'
                params.sound = false
                local zone = spawnObject(params)

                local callbackFunc = function()
                    payoutTable[caller.key][2] = searchContainer(zone.getObjects(), caller, payoutTable[caller.key][2])
                    waitFlags[caller.key] = true
                    zone.destruct()
                end
                Global.setVar(callbackName, callbackFunc)
            end

        --tabulate shares on other companies
        if caller.COMPANIES_CAN_CROSS_INVEST then

            for k,v in pairs(gameEntities.COMPANIES) do
                if k~=caller.key then
                    payoutTable[k] = {v,0}
                    waitFlags[k] = false

                    --Dynamically spawn a scripting zone to on the charter
                    local bb = getObjectFromGUID(v.charterGUID).getBoundsNormalized()
                    local params = {}
                    local callbackName = "callback" .. k
                    params.position = getObjectFromGUID(v.charterGUID).getPosition()
                    params.rotation = getObjectFromGUID(v.charterGUID).getRotation()
                    params.scale = { bb.size.x, bb.size.y+2, bb.size.z }
                    params.callback = callbackName
                    params.type = 'ScriptingTrigger'
                    params.sound = false
                    local zone = spawnObject(params)

                    local callbackFunc = function()
                        payoutTable[k][2] = searchContainer(zone.getObjects(), caller, payoutTable[k][2])
                        waitFlags[k] = true
                        zone.destruct()
                    end
                    Global.setVar(callbackName, callbackFunc)
                end
            end

        end

    end
            Wait.condition(
            function()
                transferPayouts(caller, payoutTable, amount)
            end,
            function()
                local temp = true
                for k,v in pairs(waitFlags) do
                    temp = temp and v
                end
                return temp
            end)
end

function transferPayouts(caller, payoutTable, amount)
    printToAll("--- " .. caller.name .. " pays out " .. formatLabel(amount) .. " ---")
    logTransaction(amount, 'Bank', caller.name .. ' Shares', false, true)

    if caller.PROPORTIONAL_PAYOUTS then transferPropPayouts(caller, payoutTable, amount) return end

    local someoneGotPaid = false
    for k,v in pairs(payoutTable) do
        if (v[2]~=0) then
            someoneGotPaid = true
            local calc = 0
            local string = ''
            if caller.SHARE_DESCRIPTIONS_ARE_PERCENTAGE then
                calc = math.ceil(amount*v[2]/100)
                string = v[1].name .. ' paid ' .. formatLabel(calc) .. ' for ' .. v[2] .. '%.'
            else
                calc = math.ceil(amount*v[2]/caller.issueSize)
                string = v[1].name .. ' paid ' .. formatLabel(calc) .. ' for ' .. v[2] .. ' shares (' .. v[2]*100/caller.issueSize .. '%).'
            end
            transferMoneyWithBank(v[1], calc, false, false)
            printToAll(string)
        end
    end
    if not someoneGotPaid then broadcastToAll('No company or player was paid dividends. Make sure shares are in hand or on charters.') end
end

function transferPropPayouts(caller, payoutTable, amount)
    local someoneGotPaid = false
    local allOne = true
    local shareCount = 0
    local perShare = 0
    local remainder = 0
    for k,v in pairs(payoutTable) do
        if (shareCount~=0 and v[2]~=0) then allOne = false end
        shareCount = shareCount + v[2]
    end
    perShare = math.floor(amount/shareCount)
    remainder = amount - shareCount*perShare

    for k,v in pairs(payoutTable) do
        local calc = 0
        if (v[2]~=0) then
            if allOne then
                calc = amount
            else
                calc = v[2]*perShare
            end
            string = v[1].name .. ' paid ' .. formatLabel(calc) .. ' for ' .. v[2] .. ' shares (' .. v[2] .. '/' .. shareCount .. ')'
            transferMoneyWithBank(v[1], calc, false, false)
            printToAll(string)
        end
    end
    if not allOne then Withhold(caller, remainder) end
end

function payPrivates()
    local fakeCaller = {} --hacky shit so I can use the share search function on privates
    fakeCaller.shareDescription = 'Private'

    local payoutTable = {}
    --Part of this function spawns ScriptingZones, which take more than one frame to load.
    --The waitFlags are used to make sure all ScriptingZones have loaded and done their thing before continuing.
    local waitFlags = {}

    --tabulate player privates
    for k,v in pairs(gameEntities.PLAYERS) do
        payoutTable[k] = {v, 0}
        --if player has a designated zone, search that for shares matching this company
        if getObjectFromGUID(v.shareZoneGUID) then
            payoutTable[k][2] = searchContainer(getObjectFromGUID(v.shareZoneGUID).getObjects(), fakeCaller, payoutTable[k][2])
        end
        --search the player's hand
        payoutTable[k][2] = searchContainer(Player[k].getHandObjects(), fakeCaller, payoutTable[k][2])
    end

    --tabulate company privates
    for k,v in pairs(gameEntities.COMPANIES) do
        if v.COMPANIES_CAN_OWN_PRIVATES then
            payoutTable[k] = {v,0}
            waitFlags[k] = false

            --Dynamically spawn a scripting zone to on the charter
            local bb = getObjectFromGUID(v.charterGUID).getBoundsNormalized()
            local params = {}
            local callbackName = "callback" .. k .. "private"
            params.position = getObjectFromGUID(v.charterGUID).getPosition()
            params.rotation = getObjectFromGUID(v.charterGUID).getRotation()
            params.scale = { bb.size.x, bb.size.y+2, bb.size.z }
            params.callback = callbackName
            params.type = 'ScriptingTrigger'
            params.sound = false
            local zone = spawnObject(params)

            local callbackFunc = function()
                payoutTable[k][2] = searchContainer(zone.getObjects(), fakeCaller, payoutTable[k][2])
                waitFlags[k] = true
                zone.destruct()
            end
            Global.setVar(callbackName, callbackFunc)
        end
    end

    Wait.condition(
    function()
        transferPrivatePayouts(payoutTable)
    end,
    function()
        local temp = true
        for k,v in pairs(waitFlags) do
            temp = temp and v
        end
        return temp
    end)
end

function transferPrivatePayouts(payoutTable)
    printToAll("--- Privates pay out ---")
    local someoneGotPaid = false
    for k,v in pairs(payoutTable) do
        if (v[2]~=0) then
            transferMoneyWithBank(v[1], v[2], false, false)
            printToAll(v[1].name .. ' paid ' .. formatLabel(v[2]) .. ' for Privates')
            someoneGotPaid = true
        end
    end
    if not someoneGotPaid then broadcastToAll('No company or player was paid revenue. Make sure private companies are in hand or on charters.') end
end

function searchContainer(container, caller, count)
    --this only works if container is a literal list of object values
    for i,o in ipairs(container) do
        if o.getQuantity() == -1 then
            --object is a singleton
            count = addShare(o.getDescription(),caller,count)
        else
            --object is a deck, or maybe not because getQuanity works for stacks but getObjects does not.
            if o.tag=='Deck' then
                for j,k in ipairs(o.getObjects()) do
                    count = addShare(k.description,caller,count)
                end
            end
        end
    end
    return count
end

function addShare(description, caller, count)
    --if description includes the caller's expected description then add to num
    if (string.find(description, caller.shareDescription)) then
        local num = tonumber(string.sub(description, 1+#caller.shareDescription))
        if num ~= nil then
            return (count + num)
        end
    end
    return count
end

---MISC. HELPER FUNCTIONS---

function logTransaction(amount, source, target, print, log)
    local str = os.date("%H:%M - ") .. 'Transferred ' .. formatLabel(amount) .. ' from ' .. source .. ' to ' .. target
    if print then
        printToAll(str)
    end

    if TRANSACTION_LOG and log then
        --nested tables?
        TRANSACTIONS = { next = TRANSACTIONS, value = str }
        local t = TRANSACTIONS
        local item = 0
        local transactionLog = ''
        while t and item < 9 do
            transactionLog = transactionLog .. t.value .. '\n'
            item = item + 1
            t = t.next
        end
        TRANSACTION_LOG.setDescription(transactionLog)
    end
end

function updateLabel(table_entry)
    local button_parameters = {}
    button_parameters.click_function = 'nilFunction'
    button_parameters.label = formatLabel(table_entry.treasury)
    button_parameters.position = {0, 0.11, 0}
    button_parameters.rotation = {0, 0, 0}
    button_parameters.width = 0
    button_parameters.height = 0
    button_parameters.font_size = 700
    getObjectFromGUID(table_entry.moneyLabelGUID).clearButtons()
    getObjectFromGUID(table_entry.moneyLabelGUID).createButton(button_parameters)
end

function formatLabel(number)
    local newLabel = format_int(number)
    if gameOptions.MONEY_SYMBOL then
        if gameOptions.MONEY_SYMBOL_POSITION == 'end' then
            newLabel = newLabel .. gameOptions.MONEY_SYMBOL
        else
            newLabel = gameOptions.MONEY_SYMBOL .. newLabel
        end
    end
    return newLabel
end

function format_int(number)
  local i, j, minus, int, fraction = tostring(number):find('([-]?)(%d+)([.]?%d*)')
  -- reverse the int-string and append a comma to all blocks of 3 digits
  int = int:reverse():gsub("(%d%d%d)", "%1,")
  -- reverse the int-string back remove an optional comma and put the
  -- optional minus and fractional part back
  return minus .. int:reverse():gsub("^,", "") .. fraction
end

function addv(v1, v2)
    --add vectors
    return {v1[1]+v2[1], v1[2]+v2[2], v1[3]+v2[3]}
end

function roundTo(input, roundAmount, upDown)
    --returns input rounded to roundAmount
    --if upDown = true, round up, else round down
    if upDown then
        return math.ceil(input / roundAmount) * roundAmount
    else
        return math.floor(input / roundAmount) * roundAmount
    end
end

function onPlayerChangeColor(color)
    if gameEntities.PLAYERS[color] then gameEntities.PLAYERS[color].name = Player[color].steam_name end
end

---Hardcoded values---

ERROR_COLOR = {r=1, g=0, b=0}

bankTransferParams = {}
bankTransferParams.label = 'Spend Money'
bankTransferParams.position = {0.45,0.1,0.5}
bankTransferParams.rotation = {0,180,0}
bankTransferParams.width = 400
bankTransferParams.height = 100
bankTransferParams.font_size = 50
bankTransferParams.tooltip = 'Send money to the bank'

withholdParams = {}
withholdParams.label = 'Take Money'
withholdParams.position = {-0.45,0.1,0.5}
withholdParams.rotation = {0,180,0}
withholdParams.width = 400
withholdParams.height = 100
withholdParams.font_size = 50
withholdParams.tooltip = 'Take money from the bank'

payFullParams = {}
payFullParams.label = 'Payout'
payFullParams.position = {-1,0.1,0}
payFullParams.rotation = {0,180,0}
payFullParams.width = 400
payFullParams.height = 100
payFullParams.font_size = 50

payHalfParams = {}
payHalfParams.label = 'Pay Half'
payHalfParams.position = {-1,0.1, 0}
payHalfParams.rotation = {0,180,0}
payHalfParams.width = 400
payHalfParams.height = 100
payHalfParams.font_size = 50

payPrivatesParams = {}
payPrivatesParams.label = 'Pay Privates'
payPrivatesParams.click_function = 'payPrivates'
payPrivatesParams.position = {0,0.25,0}
payPrivatesParams.width = 1600
payPrivatesParams.height = 450
payPrivatesParams.font_size = 225
